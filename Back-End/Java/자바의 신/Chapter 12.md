# 모든 클래스의 부모 클래스는 Object에요

## 모든 자바 클래스의 부모인 java.lang.Object 클래스

자바에서는 기본적으로 아무런 상속을 받지 않으면 `java.lang.Object` 클래스를 상속(확장)받는다.
자바는 한번에 다중 상속을 받을 수는 없지만, 여러 단계로 상속을 받을 수는 있다.

왜 모든 클래스는 Object 클래스를 상속 받을까? Object 클래스에 있는 메소드들을 통해서 클래스의 기본적인 행동을 정의할 수 있기 때문이다.

## toString()

Object 클래스에 구현되어 있는 `toString()` 메서드는 다음과 같다.

```java
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

현재 클래스의 패키지명, 클래스명, 객체의 해시 코드 값을 출력한다.

```java
getClass().getName() 현재 클래스의 패키지 + 클래스 이름
```

```java
Integer.toHexString(hashCode()) 객체의 해시 코드 값
```

이 값들은 잘 사용되지 않으므로 보통 오버라이딩해서 커스텀한 후 사용한다.

### toString()이 자동으로 호출되는 경우

- `System.out.println()` 메서드에 매개 변수로 들어가는 경우
- 객체에 대하여 더하기 연산을 하는 경우

## 객체는 ==만으로 같은지 확인이 안 되므로, equals()를 사용하죠

참조 자료형에서 == 연산자를 사용해도 되지만 값을 비교하는 것이 아니라 주소값을 비교한다. 즉 실제로 같은 객체를 참조하고 있는지를 비교하는 동일성 비교를 한다.

두 객체의 주소값과 상관 없이 같은 데이터를 가지고 있는지를 비교하는 동등성 비교를 위해서는, `equals()` 메소드를 사용하여 두 객체를 비교하여야 한다.

`equals()` 메소드는 객체의 주소값을 비교하는 로직을 가지고 있기 때문에 `equals()` 메소드를 오버라이딩하여 동등성 비교가 제대로 이루어지도록 구현해야 한다.

### equals() 메소드를 오버라이딩할 때 반드시 만족시켜야 할 다섯 가지 조건

- 재귀(reflexive) : null이 아닌 x라는 객체의 `x.equals(x)` 결과는 항상 true여야만 한다.
- 대칭(symmetric) : null이 아닌 x와 y 객체가 있을 때 `y.equals(x)`가 true를 리턴했다면, `x.equals(y)`도 반드시 true를 리턴해야만 한다.
- 타동적(transitive) : null이 아닌 x,y,z가 있을 때 `x.equals(y)`가 true를 리턴하고, `y.equals(z)`가 true를 리턴하면, `x.equals(z)`는 반드시 true를 리턴해야만 한다.
- 일관(consistent) : null이 아닌 x와 y가 있을 때 객체가 변경되지 않은 상황에서는 몇 번을 호출하더라도, `x.equals(y)`의 결과는 항상 true이거나 항상 false여야만 한다.
- null과의 비교 : null이 아닌 x라는 객체의 `x.equals(null)` 결과는 항상 false여야만 한다.

DTO를 만들 경우에는 데이터 비교를 위해서 반드시 필요하지만, 메소드만 있는 기능 위주의 클래스에서는 굳이 `equals()` 메소드를 오버라이딩할 필요는 없다.

## 객체의 고유값을 나타내는 hashCode()

자바 API 문서에서 `hashCode()` 메소드를 오버라이딩할 때에는 다음과 같은 조건을 따라야 한다고 명시되어 있다.

- 자바 애플리케이션이 수행되는 동안에 어떤 객체에 대해서 이 메소드가 호출될 때에는 항상 동일한 int 값을 리턴해 주어야 한다. 하지만, 자바를 실행할 때마다 같은 값이어야 할 필요는 전혀 없다.
- 어떤 두 개의 객체에 대하여 `equals()` 메소드를 사용하여 비교한 결과가 true일 경우에, 두 객체의 `hashCode()` 메소드를 호출하면 동일한 int 값을 리턴해야만 한다.
- 두 객체를 `equals()` 메소드를 사용하여 비교한 결과 false를 리턴했다고 해서, `hashCode()` 메소드를 호출한 int 값이 무조건 달라야 할 필요는 없다. 하지만, 이 경우에 서로 다른 int 값을 제공하면 hashtable의 성능을 향상시키는 데 도움이 된다.

정리하면, `equals()` 메소드를 오버라이딩할 때 `hashCode()` 메소드도 같이 오버라이딩하여 `equals()`가 true이면 해시코드도 같도록, `equals()`가 false이면 해시코드도 다르도록 일관성을 유지해야 한다.

Hash 기반 자료구조(HashSet, HashMap, HashTable)에서 객체의 동등성을 비교할 때, 객체의 해시코드가 같은지 먼저 확인하고 해시코드가 다르면 그때 객체의 데이터를 비교하기 때문이다.

